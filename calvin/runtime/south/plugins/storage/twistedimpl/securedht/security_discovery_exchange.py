"""
Security Discovery Exchange.
The purpose of this module is to create an exchange of credentials
from a new Client joining a domain to a Certificate Authority
authorizing the new Node to join the domain.

Transmit a Certificate Signature Request from a new node over multicast SSDP
to a Certificate Authority Cettificate Authority can sign request or not
depending on a configuration over unicast.
Node         Certificate Authority
 |------CSR,CA-FP---->|
 |                    | Signature()
 |<---Certificate,CA--|
 |                    |

The certificate discovery services are divided in two sections.
One for new clients and one for certificate authority functions.
By collecting and recording states for a Node and a Ca it is possible to
leave a Security Discovery Exchange at any time and continue later if a
temporary error has occured.
Errors generate exceptions and the exception handler manages the error state
unless successfull.

Use sphinx.ext.autodoc to extract comments on enums.
"""

import os

import OpenSSL

from calvin.utilities.utils import enum
from calvin.utilities import certificate
from calvin.utilities import certificate_authority
from calvin.utilities import calvinconfig
from calvin.utilities import calvinlogger

_log = calvinlogger.get_logger(__name__)


STATE = enum("NEW",  # Object is initiated but not loaded or started.
             "CONFIGURED",  # An acceptable configuration is loaded.
             "LISTENING",  # Listen for request or response.
             "TRANSMIT",  # Transmit a request or response.
             "SATISFIED",  # Required security discoveries established.
             "CSR_GENERATED",  # CSR has been generated.
             "CSR_REQUESTED",  # CSR has been requested.
             "CERTIFICATE_RECEIVED",  # Certificate has been received.
             "CERTIFICATE_VALID",  # Certificate validly signed by CA.
             "CA_ACCEPTED_CONFIGURATION",  # CAcert meets config requirements.
             "CERTIFICATE_ACCEPTED_CONFIGURATION",  # Certificate meets req.
             "CERTIFICATE_STORED",  # Certificate stored.
             "CA_GENERATED",  # CA cert generated.
             "CSR_RECEIVED",  # CSR has been received.
             "CSR_ACCEPTED",  # CSR meets config requirements.
             "CSR_STORED",  # CSR stored in new csr location
             "CSR_SIGNED",  # CSR have been signed by CA.
             "CSR_ALREDY_SIGNED",  # The requested CSR already signed.
             "CERTIFICATE_GENERATED")  # Certificate generated by CA





# Exceptions
class ConfigurationMalformed(Exception):
    """Configuration is missing required attributes to set policy."""
    pass


class CsrGenerationFailed(Exception):
    """CSR generation failed. An Error occured while generating a CSR."""
    pass


class CaDeniedConfiguration(Exception):
    """
    Ca cert is rejected due to Calvin security configuration
    or openssl.conf.
    """
    pass


class CaDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateInvalid(Exception):
    """Certificate is not validly signed by CA."""
    pass


class CertificateMalformed(Exception):
    """Certificate is not validly signed by CA."""
    pass


class CertificateDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateDeniedConfiguration(Exception):
    """Certificate is denied due to restrictions in configuration."""
    pass


class CsrDeniedConfiguration(Exception):
    """A CSR is rejected due to Calvin security configuration."""
    pass


class CsrDeniedMalformed(Exception):
    """A CSR is denied as it is malformed."""
    pass


class StoreFailed(Exception):
    """Storing failed."""
    pass


class TransmissionFailed(Exception):
    """Failed to transmit."""
    pass


class ListenFailed(Exception):
    """Listening to interface failed."""
    pass


class ListenTimeout(Exception):
    """Listening timed out before receiving anything."""
    pass


class CaNotFound(Exception):
    """The CA cert file was not found."""
    pass


class Client(object):
    """
    A Client with state and methods to maintain the Client node
    procedures in a security discovery exchange.

    Node state diagram behaviour:
    digraph N {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.CONFIGURED -> STATE.CSR_GENERATED;
        STATE.CONFIGURED -> STATE.CSR_GENERATE_FAILED;
        STATE.CSR_GENERATE_FAILED -> STATE.PANIC;
        STATE.CSR_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CSR_REQUESTED;
        STATE.TRANSMIT -> STATE.TRANSMITTING_FAILED;
        STATE.TRANSMITTING_FAILED -> STATE.PANIC;
        STATE.CSR_REQUESTED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CERTIFICATE_RECEIVED;
        STATE.LISTENING -> STATE.LISTENING_TIMEOUT;
        STATE.LISTENING_TIMEOUT -> STATE.CSR_GENERATED;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_ACCEPTED_CONFIGURATION;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_DENIED_CONFIGURATION;
        STATE.CA_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CA_DENIED_MALFORMED -> STATE.LISTENING;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_ACCEPTED_CONFIGURATION;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_DENIED_CONFIGURATION;
        STATE.CERTIFICATE_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_INVALID;
        STATE.CERTIFICATE_INVALID -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_VALID;
        STATE.CERTIFICATE_VALID ->  STATE.CERTIFICATE_STORED;
        STATE.CERTIFICATE_STORED -> STATE.STORE_FAILED;
        STATE.CERTIFICATE_STORED -> STATE.SATISFIED;
        STATE.CERTIFICATE_STORED -> STATE.CSR_GENERATED;
    }
    """

    # TODO: Add a state and function to verify that the received certificate
    # is the one issued by this csr.

    def __init__(self, name, nodeid, search, certificate_stored):
        """ Maintain state of a Node and store `configuration`.
            name is the runtime name,
            nodeid is the runtime's id,
            search is a function taking csr as kw arg to search for signing CA
            certificate_stored is a function that is called when the sign certificate is stored
        """
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.domain = self.conf.get("security","security_domain_name")
        self.nodeid = nodeid
        self.name = name
        self.search = search
        self.certificate_stored = certificate_stored
        self.discover()

    def discover(self):
        """State machine that manages client current state."""
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.csrfile = self.generate_csr()

            if self.state == STATE.CSR_GENERATED:
                self.csrdata = open(self.csrfile, 'r').read()
                self.transmit_csr(self.csrdata)

            if self.state == STATE.CSR_REQUESTED:
                # Just return and wait for response to trigger again
                return

            if self.state == STATE.CERTIFICATE_RECEIVED:
                self.validate_cert(self.certdata)

            if self.state == STATE.CERTIFICATE_VALID:
                self.store_certificate(self.certdata)
            # NOTE If we would want to support multiple CA's
            # this would be a good place to check if they were all configured.
            # self.state = self.check_configuration()
            #
            if self.state == STATE.CERTIFICATE_STORED:
                self.satisfied()

            if self.state == STATE.SATISFIED:
                return

        except (ConfigurationMalformed,
                CsrGenerationFailed,
                TransmissionFailed,
                ListenFailed,
                StoreFailed):
            # Fatal error, cause panic!
            _log.error("client.fatal_error")
            raise
        except (CaDeniedConfiguration,
                CaDeniedMalformed,
                CertificateInvalid,
                CertificateDeniedMalformed,
                CertificateDeniedConfiguration):
            # Non fatal error, should cause retry STATE.CSR_GENERATED
            _log.warning("client.non_fatal_error")
            self.state = STATE.CSR_GENERATED
            self.discover()

    def verify_configuration(self):
        """
        Verify that the self.configuration contains required fields.
        Raise ConfigurationMalformed is any required field is missing.
        """
        _log.debug("client.verify_configuration")
        try:
            if self.domain is None:
                raise ConfigurationMalformed("Missing `security_domain_name in calvin.conf")
        except (Exception), err:
            raise ConfigurationMalformed(err)
        #check if runtime already has been generated
        #and if a csr can be found

        self.state = STATE.CONFIGURED

    def generate_csr(self):
        """
        Generate CSR store csr on disk at `path`.
        Return path of new CSR.
        Rasie CsrGenerationFailed if csr generation fails.
        """
        _log.debug("client.generate_csr")
        try:
            csrfile = certificate.new_runtime(self.name, self.domain, nodeid=self.nodeid)
            self.state = STATE.CSR_GENERATED
            return csrfile
        except (IOError), err:
            raise CsrGenerationFailed(err)

    def transmit_csr(self, csr):
        """
        Transmit `csr` certificate on multicast group
        using SSDP with a desired `cafp` as a certificate authority
        fingerprint.
        """
        _log.debug("client.transmit_csr")
        self.search(csr=csr)
        self.state = STATE.CSR_REQUESTED

    def receive_cert_callback(self, certdata):
        """
        Callback for a signed certificate and a CA certificate response.
        Satisfy state STATE.CERTIFICATE_RECEIVED by receiving a certificates.
        Save certdata and continue discover process
        """
        _log.debug("client.receive_cert_callback")
        self.certdata = certdata
        self.state = STATE.CERTIFICATE_RECEIVED
        self.discover()

    # Not used
    def receive_cert(self):
        """
        Listen for a signed certificate and a CA certificate response.
        Satisfy state STATE.CERTIFICATE_RECEIVED by receiving a certificates.
        Raise ListenFailed if listening failed.
        Return cert as string.
        """
        _log.debug("client.receive_cert")
        #raise ListenFailed
        self.state = STATE.CERTIFICATE_RECEIVED
        cert = ""
        return cert

    def validate_cert(self, cert):
        """
        Confirm that a `cert` is verifiably signed with CA from config.
        """
        _log.debug("client.validate_cert")
        try:
            certificate.verify_certificate("truststore_for_transport", cert, domain=self.domain)
        except (Exception), err:
            _log.error("verification failed:%s" % err)
            raise CertificateInvalid(err)

        self.state = STATE.CERTIFICATE_VALID



    def store_certificate(self, cert):
        """
        Store a `cert` in path defined by configuration.
        raise StoreFailed if storing failed.
        raise IOError if path is not found.
        raise OSError if permissions are insuficcient.
        """
        _log.debug("client.store_certificate")
        try:
            certificate.store_own_cert(certstring=cert)
        except (Exception), err:
            _log.exception("Storing signed cert failed")
            raise StoreFailed(err)
        self.state = STATE.CERTIFICATE_STORED
        return

    def satisfied(self):
        """
        Check Node security configuration requirements and
        verify that this Node object is satisfied with its current state.
        Return True and set self.state = STATE.SATISFIED if satisfactory
        requirements are met otherwise return False and set state to desired
        next action.
        """
        _log.debug("client.satisfied")
        if self.state == STATE.CERTIFICATE_STORED:
            # This is where we check is all states have been reached.
            self.state = STATE.SATISFIED


class Ca(object):
    """
    Certificate Authority class.

    Certificate Authority state diagram behaviour:
    digraph C {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.NEW -> STATE.CONFIGURAION_FAILED;
        STATE.CONFIGURAION_FAILED -> STATE.PANIC;
        STATE.CONFIGURED -> STATE.CA_GENERATED;
        STATE.CA_GENERATED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CSR_RECEIVED;
        STATE.CSR_RECEIVED -> STATE.CSR_ACCEPTED;
        STATE.CSR_RECEIVED -> STATE.CSR_ALREDY_SIGNED;
        STATE.CSR_ALREDY_SIGNED -> STATE.TRANSMIT;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_CONFIGURATION;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_MALLFORMED;
        STATE.CSR_ACCEPTED -> STATE.CSR_STORED;
        STATE.CSR_ACCEPTED -> STATE.STORE_FAILED;
        STATE.CSR_STORED -> STATE.CERTIFICATE_GENERATED;
        STATE.CERTIFICATE_GENERATED -> STATE.STORE_FAILED;
        STATE.LISTENING -> STATE.LISTEN_FAILED;
        STATE.LISTEN_FAILED -> STATE.PANIC;
        STATE.STORE_FAILED -> STATE.PANIC;
        STATE.CERTIFICATE_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.TRANSMISSION_FAILED;
        STATE.TRANSMISSION_FAILED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CA_GENERATED;
    }
    """

    def __init__(self, name, csrdata=None):
        """Hold Ca state."""
        self.name = name
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.ca = None
        self.cafile = ""
        self.csrdata = "" if csrdata is None else csrdata
        self.csrfile = ""
        self.certfile = ""
        self.signed_cert = None
        self.is_ca = self.conf.get("security","certificate_authority")
        self.domain = self.conf.get("security","security_domain_name")
        if self.is_ca=="True":
            try:
                self.ca=certificate_authority.CA(self.domain)
            except (Exception), err:
                _log.error("CA could not be started, err={}".format(err))
                raise Exception("CA could not be started")

        if csrdata:
            self.discover()

    def discover(self):
        """
        CA service state traverser.
        Note.
        Runnign multiple instances of CA may cause problems
        as signing CSR's require serial numbers to be generated
        in serial (hence the name).
        """
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.cafile = self.find_ca()

            if self.state == STATE.LISTENING:
                self.receive_csr()

            if self.state == STATE.CSR_RECEIVED:
                self.validate_csr(self.csrdata)

            if self.state == STATE.CSR_ACCEPTED:
                self.csrfile = self.store_csr(self.csrdata)

            if self.state == STATE.CSR_STORED:
                self.certfile = self.sign_csr(self.csrfile)

            if self.state == STATE.CERTIFICATE_GENERATED:
                self.signed_cert = self.transmit_cert(self.certfile)

        except CaNotFound:
            _log.error("CA does not exist")
            self.ca = certificate_authority.CA(domain=self.domain)
            self.state = STATE.CONFIGURED
            self.discover()
            _log.error("ca.fatal_error")
            return

    def verify_configuration(self):
        """
        Verify that the self.conf and openssl.conf contains required fields.
        """
        _log.debug("ca.verify_configuration")
        if self.is_ca=="True":
            try:
                self.ca.verify_configuration()
            except (Exception), err:
                raise CaNotFound(err)
        self.state = STATE.CONFIGURED

    def find_ca(self):
        """
        Raise CaNotFound if a certificate authority cert is missing.
        Raise CaDeniedMalmformed if the configured CA is malformed.
        Also check that the private key is available
        """
        _log.debug("ca.find_ca")
        try:
            self.ca.get_ca_cert()
        except IOError:
            raise CaNotFound("Ca file not found,")
        except (OpenSSL.crypto.Error), err:
            raise CaDeniedMalformed(err)
        try:
            self.ca.verify_private_key_exist()
        except:
            raise CaNotFound("Ca private key file not found,")
        self.state = STATE.LISTENING

    def receive_csr(self):
        """
        Listen for `csr` certificate on multicast group
        using SSDP.
        Return csrdata, cadata.
        raise ListenFailed if binding to ssdp fails.
        """
        _log.debug("ca.receive_csr")
        if self.csrdata is None:
            raise ListenFailed
        self.state = STATE.CSR_RECEIVED

    def store_csr(self, csr):
        """
        Store `csr` in newcerts location from configuration.
        Raise store failed if there was problems storing.
        Return path to csr-file.
        """
        _log.debug("ca.store_csr")
        try:
            filepath=self.ca.store_csr(csr)
        except (Exception), err:
            raise StoreFailed(err)
        self.state = STATE.CSR_STORED
        return filepath

    def validate_csr(self, csr):
        """
        Validate that the `csr` matches with configuration.
        Raise CsrDeniedConfiguration if the CSR did not satisfy the
        configuration.
        Raise CsrDeniedMalformed if the csr could not be read at all.
        Raise CertDeniedConfiguration is the CSR key is too short.
        """
        _log.debug("ca.validate_csr %s" % csr)
        try:
            self.ca.validate_csr(csr)
        except (Exception), err:
            raise CsrDeniedConfiguration(err)
        self.state = STATE.CSR_ACCEPTED

    def sign_csr(self, csrfile):
        """
        Sign the `csrfile`, return certificate file path.
        Raise StoreFailed if there was a problem storing the certificate.
        """
        _log.debug("ca.sign_csr")
        try:
            certfile = self.ca.sign_csr(csrfile)
        except (IOError), err:
            raise StoreFailed(err)
        self.state = STATE.CERTIFICATE_GENERATED
        return certfile

    def transmit_cert(self, cert_file):
        """
        Transmit `cert_file` certificate, and certificate authority
        to a multicast group using SSDP by returning.
        """
        _log.debug("ca.transmit_cert")
        try:
            with open(cert_file, 'r') as ca_fd:
                cert_data = ca_fd.read()
        except (IOError), err:
            raise ListenFailed()
        self.state = STATE.TRANSMIT
        return cert_data
